{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * See <a href=\"https://www.contentful.com/developers/docs/concepts/sync/\">Synchronization</a> for more information.\n * @namespace Sync\n */\n\n\nimport { createRequestConfig, freezeSys, toPlainObject } from 'contentful-sdk-core';\nimport resolveResponse from 'contentful-resolve-response';\nimport mixinStringifySafe from './mixins/stringify-safe';\n/**\n * @memberof Sync\n * @typedef SyncCollection\n * @prop {Array<Entities.Entry>} entries - All existing entries on first sync. New and updated entries on subsequent syncs.\n * @prop {Array<Entities.Asset>} assets - All existing assets on first sync. New and updated assets on subsequent syncs.\n * @prop {Array<Sync.DeletedEntry>} deletedEntries - List of deleted Entries since last sync\n * @prop {Array<Sync.DeletedAsset>} deletedAssets - List of deleted Assets since last sync\n * @prop {string} nextSyncToken - Token to be sent to the next sync call\n * @prop {function(): Object} toPlainObject() - Returns this Sync collection as a plain JS object\n * @prop {function(?function=, space=): Object} stringifySafe(replacer,space) - Stringifies the Sync collection, accounting for circular references. Circular references will be replaced with just a Link object, with a <code>circular</code> property set to <code>true</code>. See <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\">MDN</a> and <a href=\"https://www.npmjs.com/package/json-stringify-safe\">json-stringify-safe</a> for more details on the arguments this method can take.\n */\n\n/**\n * Deleted Entries are the same as Entries, but only appear on the sync API.\n * @memberof Sync\n * @typedef DeletedEntry\n * @type Entities.Entry\n */\n\n/**\n * Deleted Assets are the same as Assets, but only appear on the sync API.\n * @memberof Sync\n * @typedef DeletedAsset\n * @type Entities.Asset\n */\n\n/**\n * This module retrieves all the available pages for a sync operation\n * @private\n * @param {Object} http - HTTP client\n * @param {Object} query - Query object\n * @param {Object} options - Sync options object\n * @param {boolean} [options.resolveLinks = true] - If links should be resolved\n * @param {boolean} [options.removeUnresolved = false] - If unresolvable links should get removed\n * @param {boolean} [options.paginate = true] - If further sync pages should automatically be crawled\n * @return {Promise<SyncCollection>}\n */\n\nexport default function pagedSync(http, query) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!query || !query.initial && !query.nextSyncToken && !query.nextPageToken) {\n    throw new Error('Please provide one of `initial`, `nextSyncToken` or `nextPageToken` parameters for syncing');\n  }\n\n  if (query && query.content_type && !query.type) {\n    query.type = 'Entry';\n  } else if (query && query.content_type && query.type && query.type !== 'Entry') {\n    throw new Error('When using the `content_type` filter your `type` parameter cannot be different from `Entry`.');\n  }\n\n  var defaultOptions = {\n    resolveLinks: true,\n    removeUnresolved: false,\n    paginate: true\n  };\n\n  var _defaultOptions$optio = _objectSpread(_objectSpread({}, defaultOptions), options),\n      resolveLinks = _defaultOptions$optio.resolveLinks,\n      removeUnresolved = _defaultOptions$optio.removeUnresolved,\n      paginate = _defaultOptions$optio.paginate;\n\n  var syncOptions = {\n    paginate: paginate\n  };\n  return getSyncPage(http, [], query, syncOptions).then(function (response) {\n    // clones response.items used in includes because we don't want these to be mutated\n    if (resolveLinks) {\n      response.items = resolveResponse(response, {\n        removeUnresolved: removeUnresolved,\n        itemEntryPoints: ['fields']\n      });\n    } // maps response items again after getters are attached\n\n\n    var mappedResponseItems = mapResponseItems(response.items);\n\n    if (response.nextSyncToken) {\n      mappedResponseItems.nextSyncToken = response.nextSyncToken;\n    }\n\n    if (response.nextPageToken) {\n      mappedResponseItems.nextPageToken = response.nextPageToken;\n    }\n\n    return freezeSys(mixinStringifySafe(toPlainObject(mappedResponseItems)));\n  }, function (error) {\n    throw error;\n  });\n}\n/**\n * @private\n * @param {Array<Entities.Entry|Entities.Array|Sync.DeletedEntry|Sync.DeletedAsset>} items\n * @return {Object} Entities mapped to an object for each entity type\n */\n\nfunction mapResponseItems(items) {\n  var reducer = function reducer(type) {\n    return function (accumulated, item) {\n      if (item.sys.type === type) {\n        accumulated.push(toPlainObject(item));\n      }\n\n      return accumulated;\n    };\n  };\n\n  return {\n    entries: items.reduce(reducer('Entry'), []),\n    assets: items.reduce(reducer('Asset'), []),\n    deletedEntries: items.reduce(reducer('DeletedEntry'), []),\n    deletedAssets: items.reduce(reducer('DeletedAsset'), [])\n  };\n}\n/**\n * If the response contains a nextPageUrl, extracts the sync token to get the\n * next page and calls itself again with that token.\n * Otherwise, if the response contains a nextSyncUrl, extracts the sync token\n * and returns it.\n * On each call of this function, any retrieved items are collected in the\n * supplied items array, which gets returned in the end\n * @private\n * @param {Object} http\n * @param {Array<Entities.Entry|Entities.Array|Sync.DeletedEntry|Sync.DeletedAsset>} items\n * @param {Object} query\n * @param {Object} options - Sync page options object\n * @param {boolean} [options.paginate = true] - If further sync pages should automatically be crawled\n * @return {Promise<{items: Array, nextSyncToken: string}>}\n */\n\n\nfunction getSyncPage(http, items, query, _ref) {\n  var paginate = _ref.paginate;\n\n  if (query.nextSyncToken) {\n    query.sync_token = query.nextSyncToken;\n    delete query.nextSyncToken;\n  }\n\n  if (query.nextPageToken) {\n    query.sync_token = query.nextPageToken;\n    delete query.nextPageToken;\n  }\n\n  if (query.sync_token) {\n    delete query.initial;\n    delete query.type;\n    delete query.content_type;\n    delete query.limit;\n  }\n\n  return http.get('sync', createRequestConfig({\n    query: query\n  })).then(function (response) {\n    var data = response.data;\n    items = items.concat(data.items);\n\n    if (data.nextPageUrl) {\n      if (paginate) {\n        delete query.initial;\n        query.sync_token = getToken(data.nextPageUrl);\n        return getSyncPage(http, items, query, {\n          paginate: paginate\n        });\n      }\n\n      return {\n        items: items,\n        nextPageToken: getToken(data.nextPageUrl)\n      };\n    } else if (data.nextSyncUrl) {\n      return {\n        items: items,\n        nextSyncToken: getToken(data.nextSyncUrl)\n      };\n    }\n  });\n}\n/**\n * Extracts token out of an url\n * @private\n */\n\n\nfunction getToken(url) {\n  var urlParts = url.split('?');\n  return urlParts.length > 0 ? urlParts[1].replace('sync_token=', '') : '';\n}","map":{"version":3,"sources":["/Users/yusukeyoshino/Desktop/React/chingu/v20-geckos-team-03/node_modules/contentful/dist/es-modules/paged-sync.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","createRequestConfig","freezeSys","toPlainObject","resolveResponse","mixinStringifySafe","pagedSync","http","query","options","undefined","initial","nextSyncToken","nextPageToken","Error","content_type","type","defaultOptions","resolveLinks","removeUnresolved","paginate","_defaultOptions$optio","syncOptions","getSyncPage","then","response","items","itemEntryPoints","mappedResponseItems","mapResponseItems","error","reducer","accumulated","item","sys","entries","reduce","assets","deletedEntries","deletedAssets","_ref","sync_token","limit","get","data","concat","nextPageUrl","getToken","nextSyncUrl","url","urlParts","split","replace"],"mappings":"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","sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * See <a href=\"https://www.contentful.com/developers/docs/concepts/sync/\">Synchronization</a> for more information.\n * @namespace Sync\n */\nimport { createRequestConfig, freezeSys, toPlainObject } from 'contentful-sdk-core';\nimport resolveResponse from 'contentful-resolve-response';\nimport mixinStringifySafe from './mixins/stringify-safe';\n/**\n * @memberof Sync\n * @typedef SyncCollection\n * @prop {Array<Entities.Entry>} entries - All existing entries on first sync. New and updated entries on subsequent syncs.\n * @prop {Array<Entities.Asset>} assets - All existing assets on first sync. New and updated assets on subsequent syncs.\n * @prop {Array<Sync.DeletedEntry>} deletedEntries - List of deleted Entries since last sync\n * @prop {Array<Sync.DeletedAsset>} deletedAssets - List of deleted Assets since last sync\n * @prop {string} nextSyncToken - Token to be sent to the next sync call\n * @prop {function(): Object} toPlainObject() - Returns this Sync collection as a plain JS object\n * @prop {function(?function=, space=): Object} stringifySafe(replacer,space) - Stringifies the Sync collection, accounting for circular references. Circular references will be replaced with just a Link object, with a <code>circular</code> property set to <code>true</code>. See <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\">MDN</a> and <a href=\"https://www.npmjs.com/package/json-stringify-safe\">json-stringify-safe</a> for more details on the arguments this method can take.\n */\n\n/**\n * Deleted Entries are the same as Entries, but only appear on the sync API.\n * @memberof Sync\n * @typedef DeletedEntry\n * @type Entities.Entry\n */\n\n/**\n * Deleted Assets are the same as Assets, but only appear on the sync API.\n * @memberof Sync\n * @typedef DeletedAsset\n * @type Entities.Asset\n */\n\n/**\n * This module retrieves all the available pages for a sync operation\n * @private\n * @param {Object} http - HTTP client\n * @param {Object} query - Query object\n * @param {Object} options - Sync options object\n * @param {boolean} [options.resolveLinks = true] - If links should be resolved\n * @param {boolean} [options.removeUnresolved = false] - If unresolvable links should get removed\n * @param {boolean} [options.paginate = true] - If further sync pages should automatically be crawled\n * @return {Promise<SyncCollection>}\n */\n\nexport default function pagedSync(http, query) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!query || !query.initial && !query.nextSyncToken && !query.nextPageToken) {\n    throw new Error('Please provide one of `initial`, `nextSyncToken` or `nextPageToken` parameters for syncing');\n  }\n\n  if (query && query.content_type && !query.type) {\n    query.type = 'Entry';\n  } else if (query && query.content_type && query.type && query.type !== 'Entry') {\n    throw new Error('When using the `content_type` filter your `type` parameter cannot be different from `Entry`.');\n  }\n\n  var defaultOptions = {\n    resolveLinks: true,\n    removeUnresolved: false,\n    paginate: true\n  };\n\n  var _defaultOptions$optio = _objectSpread(_objectSpread({}, defaultOptions), options),\n      resolveLinks = _defaultOptions$optio.resolveLinks,\n      removeUnresolved = _defaultOptions$optio.removeUnresolved,\n      paginate = _defaultOptions$optio.paginate;\n\n  var syncOptions = {\n    paginate: paginate\n  };\n  return getSyncPage(http, [], query, syncOptions).then(function (response) {\n    // clones response.items used in includes because we don't want these to be mutated\n    if (resolveLinks) {\n      response.items = resolveResponse(response, {\n        removeUnresolved: removeUnresolved,\n        itemEntryPoints: ['fields']\n      });\n    } // maps response items again after getters are attached\n\n\n    var mappedResponseItems = mapResponseItems(response.items);\n\n    if (response.nextSyncToken) {\n      mappedResponseItems.nextSyncToken = response.nextSyncToken;\n    }\n\n    if (response.nextPageToken) {\n      mappedResponseItems.nextPageToken = response.nextPageToken;\n    }\n\n    return freezeSys(mixinStringifySafe(toPlainObject(mappedResponseItems)));\n  }, function (error) {\n    throw error;\n  });\n}\n/**\n * @private\n * @param {Array<Entities.Entry|Entities.Array|Sync.DeletedEntry|Sync.DeletedAsset>} items\n * @return {Object} Entities mapped to an object for each entity type\n */\n\nfunction mapResponseItems(items) {\n  var reducer = function reducer(type) {\n    return function (accumulated, item) {\n      if (item.sys.type === type) {\n        accumulated.push(toPlainObject(item));\n      }\n\n      return accumulated;\n    };\n  };\n\n  return {\n    entries: items.reduce(reducer('Entry'), []),\n    assets: items.reduce(reducer('Asset'), []),\n    deletedEntries: items.reduce(reducer('DeletedEntry'), []),\n    deletedAssets: items.reduce(reducer('DeletedAsset'), [])\n  };\n}\n/**\n * If the response contains a nextPageUrl, extracts the sync token to get the\n * next page and calls itself again with that token.\n * Otherwise, if the response contains a nextSyncUrl, extracts the sync token\n * and returns it.\n * On each call of this function, any retrieved items are collected in the\n * supplied items array, which gets returned in the end\n * @private\n * @param {Object} http\n * @param {Array<Entities.Entry|Entities.Array|Sync.DeletedEntry|Sync.DeletedAsset>} items\n * @param {Object} query\n * @param {Object} options - Sync page options object\n * @param {boolean} [options.paginate = true] - If further sync pages should automatically be crawled\n * @return {Promise<{items: Array, nextSyncToken: string}>}\n */\n\n\nfunction getSyncPage(http, items, query, _ref) {\n  var paginate = _ref.paginate;\n\n  if (query.nextSyncToken) {\n    query.sync_token = query.nextSyncToken;\n    delete query.nextSyncToken;\n  }\n\n  if (query.nextPageToken) {\n    query.sync_token = query.nextPageToken;\n    delete query.nextPageToken;\n  }\n\n  if (query.sync_token) {\n    delete query.initial;\n    delete query.type;\n    delete query.content_type;\n    delete query.limit;\n  }\n\n  return http.get('sync', createRequestConfig({\n    query: query\n  })).then(function (response) {\n    var data = response.data;\n    items = items.concat(data.items);\n\n    if (data.nextPageUrl) {\n      if (paginate) {\n        delete query.initial;\n        query.sync_token = getToken(data.nextPageUrl);\n        return getSyncPage(http, items, query, {\n          paginate: paginate\n        });\n      }\n\n      return {\n        items: items,\n        nextPageToken: getToken(data.nextPageUrl)\n      };\n    } else if (data.nextSyncUrl) {\n      return {\n        items: items,\n        nextSyncToken: getToken(data.nextSyncUrl)\n      };\n    }\n  });\n}\n/**\n * Extracts token out of an url\n * @private\n */\n\n\nfunction getToken(url) {\n  var urlParts = url.split('?');\n  return urlParts.length > 0 ? urlParts[1].replace('sync_token=', '') : '';\n}"]},"metadata":{},"sourceType":"module"}